/*
 * Copyright (c) 2016, WSO2 Inc. (http://www.wso2.org) All Rights Reserved.
 *
 * WSO2 Inc. licenses this file to you under the Apache License,
 * Version 2.0 (the "License"); you may not use this file except
 * in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package org.wso2.carbon.uuf.maven.parser;

import org.wso2.carbon.uuf.maven.exception.ParsingException;
import org.wso2.carbon.uuf.maven.model.DependencyNode;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;

/**
 * Parser for dependency tree generated by executing goal {@code tree} of Maven Dependency plugin with {@code
 * outputType=text} and {@code verbose=true} parameters.({@code mvn dependency:tree -DoutputType=text -Dverbose=true})
 *
 * @since 1.0.0
 */
public class DependencyTreeParser {

    /**
     * Parses the specified dependency tree file.
     *
     * @param dependencyTreeFilePath path to dependency tree file
     * @return root node of the dependency tree
     * @throws ParsingException if cannot read or parse the content of the dependency tree file
     */
    public static DependencyNode parse(String dependencyTreeFilePath) throws ParsingException {
        List<String> lines;
        try {
            lines = Files.readAllLines(Paths.get(dependencyTreeFilePath));
        } catch (IOException e) {
            throw new ParsingException("Cannot read the content of dependency tree '" + dependencyTreeFilePath + "'.",
                                       e);
        }
        return parseLines(lines);
    }

    /**
     * Parses the specified dependency tree text.
     *
     * @param dependencyTreeLines lines of the dependency tree to parse
     * @return root node of the dependency tree
     * @throws ParsingException if an error occurred when parsing the dependency tree
     */
    static DependencyNode parseLines(List<String> dependencyTreeLines) throws ParsingException {
        // First line is the root node.
        DependencyNode rootNode = createDependencyNode(dependencyTreeLines.get(0), null);

        int previousLevel = 0;
        DependencyNode currentParentNode = rootNode; // parent node of the current line
        DependencyNode previousNode = rootNode; // node created in the previous iteration
        for (int i = 1; i < dependencyTreeLines.size(); i++) {
            String line = dependencyTreeLines.get(i);
            int level = countLevel(line);
            int jump = (level - previousLevel);

            DependencyNode currentNode;
            if (jump < 0) {
                // Found a sibling, of the 'currentParentNode' or one of the 'currentParentNode's parent.
                currentParentNode = currentParentNode.getParent(jump * -1);
                currentNode = createDependencyNode(line, currentParentNode);
                currentParentNode.addDependency(currentNode);
            } else if (jump == 0) {
                // Found a sibling of the previously added node.
                currentNode = createDependencyNode(line, currentParentNode);
                currentParentNode.addDependency(currentNode);
            } else if (jump == 1) {
                // Found a dependency of the previously added node.
                currentParentNode = previousNode;
                currentNode = createDependencyNode(line, currentParentNode);
                currentParentNode.addDependency(currentNode);
            } else {
                // jump > 1, this cannot happen
                throw new ParsingException("Delta between current level (" + level + ") and previous level (" +
                                                   previousLevel + ") cannot be greater than 1.");
            }

            previousLevel = level;
            previousNode = currentNode;
        }

        return rootNode;
    }

    private static int countLevel(String line) {
        int indent = 0;
        for (int i = 0; i < line.length(); i++) {
            char c = line.charAt(i);
            if (c == '+' || c == ' ' || c == '\\' || c == '|') {
                indent++;
            } else {
                break;
            }
        }
        return (indent <= 1) ? indent : (indent / 2);
    }

    private static DependencyNode createDependencyNode(String dependencyLine, DependencyNode parent)
            throws ParsingException {
        String[] parts = dependencyLine.split(":");
        switch (parts.length) {
            case 4:
                // <Group ID>:<Artifact ID>:<Artifact Type>:<Version>
            case 5:
                // <Group ID>:<Artifact ID>:<Artifact Type>:<Version>:<Scope>
                // (<Group ID>:<Artifact ID>:<Artifact Type>:<Version>:<Scope> - omitted for duplicate)
                return new DependencyNode(parts[1], parts[3], parent);
            case 6:
                // <Group ID>:<Artifact ID>:<Artifact Type>:<Classifier>:<Version>:<Scope>
                // (<Group ID>:<Artifact ID>:<Artifact Type>:<Classifier>:<Version>:<Scope> - omitted for duplicate)
                return new DependencyNode(parts[1], parts[4], parent);
            default:
                throw new ParsingException(
                        "Format of dependency line '" + dependencyLine + "' is incorrect. Found " + parts.length +
                                " parts instead of 4 or 5 or 6.");
        }
    }
}
